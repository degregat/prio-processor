#!/bin/bash

# This script controls the docker-compose workflow for integration testing. The
# containers are defined in the docker-compose.yml, but are orchestrated through
# this script for verification.

set -euo pipefail

export DATA_CONFIG=${DATA_CONFIG:-/app/config/test-small.json}
docker-compose up -d

function clean_buckets {
    docker-compose run server_a bin/cleanup
    docker-compose run server_b bin/cleanup
}

# Add a cleanup handler for the exit signal
function cleanup {
    clean_buckets
    docker-compose down
}
trap cleanup EXIT

# Copy data into the appropriate buckets
docker-compose run -e DATA_CONFIG admin bin/generate

# Start server A
docker-compose run -e DATA_CONFIG server_a bin/process &
server_a_pid=$!

# offset the start times by a short amount for proper authentication against GCP
sleep 2

# Start server B
docker-compose run -e DATA_CONFIG server_b bin/process &
server_b_pid=$!

# Return the exit code of the backgrounded docker-compose container. Since
# `wait` is a blocking function, a failure in server B will not be detected
# until timeout in server A.
wait $server_a_pid
wait $server_b_pid

docker-compose run -e DATA_CONFIG admin bin/insert
